use std::fmt::Display;

#[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
pub enum ReservedWord {
    Assign = '=' as isize,
    LeftParenthesis = '(' as isize,
    RightParenthesis = ')' as isize,
    LeftCurly = '{' as isize,
    RightCurly = '}' as isize,
    LeftSquareBracket = '[' as isize,
    RightSquareBracket = ']' as isize,
    Period = '.' as isize,
    Comma = ',' as isize,
    SemiColon = ';' as isize,
    Add = '+' as isize,
    Mult = '*' as isize,
    Div = '/' as isize,
    Sub = '-' as isize,
    Mod = '%' as isize,
    Less = '<' as isize,
    Greater = '>' as isize,
    And = '&' as isize,
    Or = '|' as isize,
    Xor = '^' as isize,
    Not = '~' as isize,
    LogicalNot = '!' as isize,
    Arrow = 1000,
    Const,
    Let,
    Import,
    Export,
    Default,
    From,
    False,
    True,
    LeftShift,
    RightShift,
    UnsignedRightShift,
    LessOrEq,
    GreaterOrEq,
    Equal,
    NotEqual,
    Exponential,
    LogicalAnd,
    LogicalOr,
    AdditiveAssign,
    SubtractiveAssign,
    MultiplicativeAssign,
    DivisiveAssign,
    ModuloAssign,
    LeftShiftAssign,
    RightShiftAssign,
    UnsignedRightShiftAssign,
    AndAssign,
    XorAssign,
    OrAssign,
    ExponentialAssign,
}

impl Display for ReservedWord {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let text = if *self < ReservedWord::Arrow {
            (*self as u8 as char).to_string()
        } else {
            String::from(match *self {
                ReservedWord::Arrow => "=>",
                ReservedWord::Const => "const",
                ReservedWord::Let => "let",
                ReservedWord::Import => "import",
                ReservedWord::Export => "export",
                ReservedWord::Default => "default",
                ReservedWord::From => "from",
                ReservedWord::True => "true",
                ReservedWord::False => "false",
                ReservedWord::LeftShift => "<<",
                ReservedWord::RightShift => ">>",
                ReservedWord::UnsignedRightShift => ">>>",
                ReservedWord::LessOrEq => "<=",
                ReservedWord::GreaterOrEq => ">=",
                ReservedWord::Equal => "==",
                ReservedWord::NotEqual => "!=",
                ReservedWord::Exponential => "**",
                ReservedWord::LogicalAnd => "&&",
                ReservedWord::LogicalOr => "||",
                ReservedWord::AdditiveAssign => "+=",
                ReservedWord::SubtractiveAssign => "-=",
                ReservedWord::MultiplicativeAssign => "*=",
                ReservedWord::DivisiveAssign => "/=",
                ReservedWord::ModuloAssign => "%=",
                ReservedWord::LeftShiftAssign => "<<=",
                ReservedWord::RightShiftAssign => ">>=",
                ReservedWord::UnsignedRightShiftAssign => ">>>=",
                ReservedWord::AndAssign => "&=",
                ReservedWord::XorAssign => "^=",
                ReservedWord::OrAssign => "|=",
                ReservedWord::ExponentialAssign => "**=",
                _ => panic!(),
            })
        };
        write!(f, "{}", text)
    }
}

#[cfg(test)]
mod tests {
    use super::ReservedWord::*;

    #[test]
    fn test_to_string() {
        let reserveds = vec![
            Assign,
            LeftParenthesis,
            RightParenthesis,
            LeftCurly,
            RightCurly,
            LeftSquareBracket,
            RightSquareBracket,
            Period,
            Comma,
            SemiColon,
            Arrow,
            Add,
            Mult,
            Div,
            Sub,
            Mod,
            LeftShift,
            RightShift,
            UnsignedRightShift,
            Less,
            Greater,
            LessOrEq,
            GreaterOrEq,
            Equal,
            NotEqual,
            Exponential,
            And,
            Or,
            Xor,
            Not,
            LogicalNot,
            LogicalAnd,
            LogicalOr,
            AdditiveAssign,
            SubtractiveAssign,
            MultiplicativeAssign,
            DivisiveAssign,
            ModuloAssign,
            LeftShiftAssign,
            RightShiftAssign,
            UnsignedRightShiftAssign,
            AndAssign,
            XorAssign,
            OrAssign,
            ExponentialAssign,
            Const,
            Let,
            Import,
            Export,
            Default,
            From,
            True,
            False,
        ];
        for item in reserveds {
            match item {
                Assign => assert_eq!("=", item.to_string()),
                LeftParenthesis => assert_eq!("(", item.to_string()),
                RightParenthesis => assert_eq!(")", item.to_string()),
                LeftCurly => assert_eq!("{", item.to_string()),
                RightCurly => assert_eq!("}", item.to_string()),
                LeftSquareBracket => assert_eq!("[", item.to_string()),
                RightSquareBracket => assert_eq!("]", item.to_string()),
                Period => assert_eq!(".", item.to_string()),
                Comma => assert_eq!(",", item.to_string()),
                SemiColon => assert_eq!(";", item.to_string()),
                Arrow => assert_eq!("=>", item.to_string()),
                Const => assert_eq!("const", item.to_string()),
                Let => assert_eq!("let", item.to_string()),
                Import => assert_eq!("import", item.to_string()),
                Export => assert_eq!("export", item.to_string()),
                Default => assert_eq!("default", item.to_string()),
                From => assert_eq!("from", item.to_string()),
                True => assert_eq!("true", item.to_string()),
                False => assert_eq!("false", item.to_string()),
                Add => assert_eq!("+", item.to_string()),
                Mult => assert_eq!("*", item.to_string()),
                Div => assert_eq!("/", item.to_string()),
                Sub => assert_eq!("-", item.to_string()),
                Mod => assert_eq!("%", item.to_string()),
                Less => assert_eq!("<", item.to_string()),
                Greater => assert_eq!(">", item.to_string()),
                LeftShift => assert_eq!("<<", item.to_string()),
                RightShift => assert_eq!(">>", item.to_string()),
                UnsignedRightShift => assert_eq!(">>>", item.to_string()),
                LessOrEq => assert_eq!("<=", item.to_string()),
                GreaterOrEq => assert_eq!(">=", item.to_string()),
                Equal => assert_eq!("==", item.to_string()),
                NotEqual => assert_eq!("!=", item.to_string()),
                AdditiveAssign => assert_eq!("+=", item.to_string()),
                SubtractiveAssign => assert_eq!("-=", item.to_string()),
                MultiplicativeAssign => assert_eq!("*=", item.to_string()),
                DivisiveAssign => assert_eq!("/=", item.to_string()),
                ModuloAssign => assert_eq!("%=", item.to_string()),
                LeftShiftAssign => assert_eq!("<<=", item.to_string()),
                RightShiftAssign => assert_eq!(">>=", item.to_string()),
                UnsignedRightShiftAssign => assert_eq!(">>>=", item.to_string()),
                AndAssign => assert_eq!("&=", item.to_string()),
                XorAssign => assert_eq!("^=", item.to_string()),
                OrAssign => assert_eq!("|=", item.to_string()),
                ExponentialAssign => assert_eq!("**=", item.to_string()),
                And => assert_eq!("&", item.to_string()),
                Or => assert_eq!("|", item.to_string()),
                Xor => assert_eq!("^", item.to_string()),
                Not => assert_eq!("~", item.to_string()),
                Exponential => assert_eq!("**", item.to_string()),
                LogicalAnd => assert_eq!("&&", item.to_string()),
                LogicalNot => assert_eq!("!", item.to_string()),
                LogicalOr => assert_eq!("||", item.to_string()),
            }
        }
    }
}
